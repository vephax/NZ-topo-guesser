<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Max's Organic Synthesis AI Sloppifier</title>
  <style>
    :root {
      --bg-primary: #f0f4f8;
      --bg-secondary: white;
      --bg-tertiary: #f9fbff;
      --text-primary: #1a1a2e;
      --text-secondary: #2c3e50;
      --text-muted: #555;
      --border-color: #e0e0e0;
      --border-light: #e0e0f0;
      --accent-primary: #007bff;
      --accent-hover: #a0d8ff;
      --step-bg: #e8f4fc;
      --step-border: #bde0fd;
      --drag-bg: #f0f8ff;
      --drag-hover: #d0ebff;
      --success-bg: #d4edda;
      --success-text: #155724;
      --success-border: #c3e6cb;
      --error-bg: #f8d7da;
      --error-text: #721c24;
      --error-border: #f5c6cb;
      --fact-bg: #fffbe6;
      --fact-border: #ffeaa7;
    }

    [data-theme="dark"] {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f1419;
      --text-primary: #e2e8f0;
      --text-secondary: #f1f5f9;
      --text-muted: #94a3b8;
      --border-color: #334155;
      --border-light: #475569;
      --accent-primary: #3b82f6;
      --accent-hover: #1e40af;
      --step-bg: #1e293b;
      --step-border: #334155;
      --drag-bg: #2c3a50;
      --drag-hover: #475569;
      --success-bg: #064e3b;
      --success-text: #6ee7b7;
      --success-border: #047857;
      --error-bg: #7f1d1d;
      --error-text: #fca5a5;
      --error-border: #dc2626;
      --fact-bg: #451a03;
      --fact-border: #92400e;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 20px;
      transition: all 0.3s ease;
    }

    .container {
      max-width: 1400px;
      margin: auto;
      background: var(--bg-secondary);
      border-radius: 14px;
      box-shadow: 0 6px 25px rgba(0,0,0,0.1);
      padding: 25px;
      display: grid;
      grid-template-columns: 200px 1fr 200px;
      grid-template-rows: auto 1fr auto auto;
      gap: 20px;
      position: relative;
    }

    /* STICKY MODE: side pools stick to screen */
    .container.sticky-pools .conditions-pool,
    .container.sticky-pools .reagents-pool {
      position: sticky;
      top: 20px;
      height: calc(100vh - 40px);
      overflow-y: auto;
      z-index: 10;
      padding: 15px;
    }
    .container.sticky-pools .conditions-pool {
      left: 20px;
    }
    .container.sticky-pools .reagents-pool {
      right: 20px;
    }

    header {
      grid-column: 1 / 4;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 12px;
    }
    h1 {
      margin: 0;
      font-size: 1.5em;
      color: var(--text-secondary);
    }

    .header-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .theme-toggle, .sticky-toggle {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      cursor: pointer;
      border-radius: 6px;
      font-size: 0.8em;
    }
    .diff-btn {
      padding: 10px 14px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      cursor: pointer;
      border-radius: 8px;
      font-size: 0.9em;
      color: var(--text-primary);
    }
    .diff-btn.active {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
    }

    /* Sidebars */
    .conditions-pool, .reagents-pool {
      background: var(--bg-tertiary);
      border: 1px dashed var(--border-light);
      border-radius: 10px;
      min-height: 200px;
    }
    .conditions-pool h3, .reagents-pool h3 {
      margin: 0 0 10px;
      font-size: 0.95em;
      color: var(--text-secondary);
    }

    /* Main: Synthesis Path */
    .main-area {
      grid-column: 2;
    }

    .compound-box {
      padding: 16px;
      font-weight: bold;
      font-size: 1.2em;
      min-width: 160px;
      text-align: center;
      border-radius: 10px;
      margin: 8px 0;
    }
    .compound-box.start {
      background: #e3f2fd;
      border: 2px solid #2196f3;
    }
    .compound-box.intermediate {
      background: #fff3e0;
      border: 2px solid #ff9800;
    }
    .compound-box.target {
      background: #f0fff4;
      border: 2px solid #4caf50;
      color: #155724;
    }

    /* Step layout */
    .step {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      margin: 40px 0;
      width: 100%;
      justify-content: center;
    }

    .condition-drop {
      min-width: 120px;
      text-align: center;
    }

    .arrow-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .arrow {
      font-size: 2em;
      color: var(--text-muted);
    }

    .reagent-drop {
      min-width: 120px;
      text-align: center;
    }

    /* STICKY Intermediate Product Drop Zone */
    .product-drop {
      grid-column: 2;
      text-align: center;
      margin: 20px 0;
      position: -webkit-sticky;
      position: sticky;
      top: 100px;
      z-index: 10;
      pointer-events: none;
    }

    .product-drop > .drop-zone {
      pointer-events: auto;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 12px 16px;
      min-height: 60px;
      max-width: 180px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(6px);
      border: 2px dashed var(--border-light);
      border-radius: 10px;
      color: var(--text-muted);
      font-style: italic;
      transition: all 0.2s ease;
    }

    .product-drop > .drop-zone.filled {
      background: var(--step-bg);
      color: var(--text-primary);
      font-style: normal;
      border-color: var(--step-border);
    }

    .product-drop > .drop-zone:hover {
      border-color: var(--accent-primary);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    }

    .drop-zone .tag {
      background: var(--accent-primary);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
      cursor: pointer;
    }
    .drop-zone .tag::after {
      content: " √ó";
      font-weight: bold;
    }
    .drop-zone .tag:hover::after {
      color: red;
    }

    /* Bottom: Products Pool */
    .products-pool {
      grid-column: 1 / 4;
      background: var(--bg-tertiary);
      border: 1px dashed var(--border-light);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    .products-pool h3 {
      margin: 0 0 10px;
      font-size: 0.95em;
      color: var(--text-secondary);
    }

    /* Controls */
    .controls {
      grid-column: 1 / 4;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    button.primary {
      background: var(--accent-primary);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
    }
    button.secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
    }

    .feedback {
      grid-column: 1 / 4;
      margin: 10px 0;
      padding: 14px;
      border-radius: 8px;
      font-size: 0.95em;
      display: none;
      white-space: pre-line;
    }
    .feedback.ok {
      background: var(--success-bg);
      color: var(--success-text);
      border: 1px solid var(--success-border);
    }
    .feedback.bad {
      background: var(--error-bg);
      color: var(--error-text);
      border: 1px solid var(--error-border);
    }
    .fact-box {
      grid-column: 1 / 4;
      margin: 10px 0;
      padding: 14px;
      background: var(--fact-bg);
      border: 1px dashed var(--fact-border);
      border-radius: 8px;
      font-size: 0.9em;
      white-space: pre-line;
      display: none;
    }
    footer {
      grid-column: 1 / 4;
      margin-top: 20px;
      text-align: center;
      font-size: 0.85em;
      color: var(--text-muted);
    }

    .draggable {
      padding: 8px 12px;
      background: var(--option-bg);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: move;
      font-size: 0.9em;
      min-width: 90px;
      text-align: center;
      display: inline-block;
      margin: 4px;
    }
    .draggable.condition { background: #e8f4fc; border-color: #2196f3; }
    .draggable.reagent  { background: #f3e5f5; border-color: #9c27b0; }
    .draggable.product  { background: #fff3e0; border-color: #ff9800; }
  </style>
</head>
<body data-theme="light">
  <div class="container">
    <header>
      <h1>Max's Organic Synthesis Tree</h1>
      <div class="header-controls">
        <button id="theme-toggle" class="theme-toggle">üåô Dark</button>
        <button id="sticky-toggle" class="sticky-toggle">üìå Sticky Pools</button>
        <button id="diff-baby" class="diff-btn">Baby (2)</button>
        <button id="diff-easy" class="diff-btn active">Easy (3)</button>
        <button id="diff-med" class="diff-btn">Medium (4)</button>
        <button id="diff-hard" class="diff-btn">Hard (5)</button>
        <button id="diff-evil" class="diff-btn">Evil (10)</button>
      </div>
    </header>

    <!-- Left: Conditions -->
    <div class="conditions-pool">
      <h3>Drag Condition (‚Üê)</h3>
      <div id="conditions-pool"></div>
    </div>

    <!-- Main: Synthesis Path -->
    <div class="main-area">
      <div class="compound-box start" id="start">?</div>
      <div id="steps-container"></div>
      <div class="compound-box target" id="target">?</div>
    </div>

    <!-- Right: Reagents -->
    <div class="reagents-pool">
      <h3>Drag Reagent (‚Üí)</h3>
      <div id="reagents-pool"></div>
    </div>

    <!-- Bottom: Products -->
    <div class="products-pool">
      <h3>Drag Intermediate (‚Üì)</h3>
      <div id="products-pool"></div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="submit" class="primary">Submit Pathway</button>
      <button id="helpful-hint" class="secondary">Helpful Hint</button>
      <button id="reset" class="secondary">Reset</button>
      <button id="show-answer" class="secondary">Show Answer</button>
    </div>

    <div id="feedback" class="feedback"></div>
    <div id="fact" class="fact-box"></div>

    <footer>
      Build a synthesis from start to target.<br>
      Drag: condition (‚Üê), intermediate (‚Üì), reagent (‚Üí).<br>
      Multiple items allowed. Click tags to remove.<br>
      Side pools and intermediates are STICKY when enabled.<br>
      Made with AI slop. any questions idgaf. This is beauty.
    </footer>
  </div>

  <script>
  document.addEventListener("DOMContentLoaded", () => {
    let isDark = false;
    let isSticky = false;
    let difficulty = "easy";
    let correctPath = [];
    let userSteps = [];
    let start = "";
    let target = "";

    const $ = id => document.getElementById(id);
    const feedbackEl = $("feedback");
    const factEl = $("fact");

    const reactions = [
      { from: "Alkene", to: "Alkane", reagents: ["H‚ÇÇ"], conditions: ["catalyst", "heat"], type: ["Addition"], fact: "Hydrogenation: adds H‚ÇÇ across double bond. Requires metal catalyst." },
      { from: "Alkene", to: "Addition Polymer", reagents: ["R-C=C-R"], conditions: ["catalyst", "heat", "pressure"], type: ["Addition", "Condensation"], fact: "Polymerisation where a polymer is polymerised (=." },
      { from: "Alkene", to: "Haloalkane", reagents: ["HI", "HBr", "HCl"], conditions: [], type: ["Addition"], fact: "Electrophilic addition. Br‚ÇÇ decolorizes from red-brown to colorless." },
      { from: "Alkene", to: "Dihaloalkane", reagents: ["I‚ÇÇ", "Cl‚ÇÇ", "Br‚ÇÇ"], conditions: [], type: ["Addition"], fact: "Electrophilic addition. Br‚ÇÇ decolorizes from red-brown to colorless." },
      { from: "Alkene", to: "Alcohol", reagents: ["dil. H‚ÇÇSO‚ÇÑ"], conditions: ["heat"], type: ["Addition"], fact: "Acid-catalyzed hydration follows Markovnikov's rule." },
      { from: "Alkene", to: "Diol", reagents: ["Cr‚ÇÇO‚Çá¬≤‚Åª", "MnO‚ÇÑ‚Åª"], conditions: ["cold"], type: ["Addition"], fact: "Oxidises alkenes to glycols (diols)." },
      { from: "Alkane", to: "Haloalkane", reagents: ["Cl‚ÇÇ", "Br‚ÇÇ", "I‚ÇÇ"], conditions: ["uv"], type: ["Substitution"], fact: "UV light initiates radical chain reaction. Mixture of products possible." },
      { from: "Alcohol", to: "Haloalkane", reagents: ["PCl‚ÇÉ", "PCl‚ÇÖ", "SOCl‚ÇÇ", "HBr", "HI"], conditions: ["reflux"], type: ["Substitution"], fact: "Converts OH to halide. SN2 for 1¬∞, SN1 for 3¬∞." },
      { from: "Haloalkane", to: "Alcohol", reagents: ["aq. KOH"], conditions: ["reflux"], type: ["Substitution"], fact: "OH‚Åª replaces halogen. SN2 for 1¬∞, SN1 for 3¬∞." },
      { from: "Haloalkane", to: "Amine", reagents: ["conc. NH‚ÇÉ"], conditions: ["heat"], type: ["Substitution"], fact: "Forms primary amine. Excess NH‚ÇÉ prevents further substitution." },
      { from: "Alcohol (1¬∞)", to: "Aldehyde", reagents: ["Cr‚ÇÇO‚Çá¬≤‚Åª / H‚Å∫", "MnO‚ÇÑ‚Åª / H‚Å∫"], conditions: ["distil"], type: ["Oxidation"], fact: "Distillation stops at aldehyde before over-oxidation." },
      { from: "Alcohol (1¬∞)", to: "Carboxylic Acid", reagents: ["Cr‚ÇÇO‚Çá¬≤‚Åª / H‚Å∫", "MnO‚ÇÑ‚Åª / H‚Å∫"], conditions: ["reflux"], type: ["Oxidation"], fact: "Fully oxidizes to carboxylic acid." },
      { from: "Alcohol (2¬∞)", to: "Ketone", reagents: ["Cr‚ÇÇO‚Çá¬≤‚Åª / H‚Å∫", "MnO‚ÇÑ‚Åª / H‚Å∫"], conditions: ["reflux"], type: ["Oxidation"], fact: "Ketones resist further oxidation." },
      { from: "Alcohol", to: "Alkene", reagents: ["conc. H‚ÇÇSO‚ÇÑ"], conditions: ["heat"], type: ["Elimination"], fact: "Dehydration removes water. Zaitsev's rule applies." },
      { from: "Aldehyde", to: "Carboxylic Acid", reagents: ["Cr‚ÇÇO‚Çá¬≤‚Åª / H‚Å∫", "MnO‚ÇÑ‚Åª / H‚Å∫"], conditions: ["reflux"], type: ["Oxidation"], fact: "Aldehydes are easily oxidized; ketones are not." },
      { from: "Aldehyde", to: "Alcohol (1¬∞)", reagents: ["NaBH‚ÇÑ", "LiAlH‚ÇÑ"], conditions: [], type: ["Reduction"], fact: "Reduces to primary alcohols." },
      { from: "Ketone", to: "Alcohol (2¬∞)", reagents: ["NaBH‚ÇÑ", "LiAlH‚ÇÑ"], conditions: [], type: ["Reduction"], fact: "Reduces to secondary alcohols." },
      { from: "Carboxylic Acid", to: "Acid Chloride", reagents: ["PCl‚ÇÉ", "PCl‚ÇÖ", "SOCl‚ÇÇ"], conditions: [], type: ["Substitution"], fact: "SOCl‚ÇÇ preferred; byproducts are gases." },
      { from: "Carboxylic Acid", to: "Ester", reagents: ["R-OH", "conc. H‚ÇÇSO‚ÇÑ"], conditions: ["reflux"], type: ["Condensation"], fact: "Esterification with alcohols." },
      { from: "Alcohol", to: "Ester", reagents: ["R-COOH", "conc. H‚ÇÇSO‚ÇÑ"], conditions: ["reflux"], type: ["Condensation"], fact: "Esterification with carboxylic acids." },
      { from: "Acid Chloride", to: "Ester", reagents: ["R-OH"], conditions: [], type: ["Condensation"], fact: "Fast, exothermic ester formation." },
      { from: "Acid Chloride", to: "Amide (1¬∞)", reagents: ["conc. NH‚ÇÉ", "alc. NH‚ÇÉ"], conditions: [], type: ["Substitution", "Condensation"], fact: "Forms primary amides; HCl gas produced." },
      { from: "Acid Chloride", to: "Amide (2¬∞)", reagents: ["R-NH‚ÇÇ"], conditions: [], type: ["Substitution", "Condensation"], fact: "Forms secondary amides; HCl gas produced." },
      { from: "Acid Chloride", to: "Carboxylic Acid", reagents: ["H‚ÇÇO"], conditions: [], type: ["Hydrolysis", "Substitution"], fact: "Rapid hydrolysis to carboxylic acid." },
      { from: "Carboxylic Acid", to: "Amide", reagents: ["conc. NH‚ÇÉ", "alc. NH‚ÇÉ"], conditions: ["heat"], type: ["Condensation", "Substitution"], fact: "Forms amides; water is a byproduct." },
      { from: "Ester", to: "Carboxylic Acid", reagents: ["H‚ÇÇO"], conditions: ["acidic", "reflux"], type: ["Hydrolysis"], fact: "Acidic hydrolysis is reversible." },
      { from: "Ester", to: "Carboxylate", reagents: ["H‚ÇÇO"], conditions: ["basic", "reflux"], type: ["Hydrolysis"], fact: "Saponification produces soap." },
      { from: "Ester", to: "Amide", reagents: ["conc. NH‚ÇÉ", "alc. NH‚ÇÉ"], conditions: ["reflux"], type: ["Hydrolysis"], fact: "Ammonolysis forms amides." },
      { from: "Amide", to: "Amine", reagents: ["NaBH‚ÇÑ", "LiAlH‚ÇÑ"], conditions: [], type: ["Reduction"], fact: "LiAlH‚ÇÑ reduces amides to amines." },
      { from: "Amine", to: "Ammonium Salt", reagents: ["H‚ÇÇO"], conditions: ["acidic"], type: ["Acid-Base"], fact: "Amines react with acids to form salts." },
      { from: "Ammonium Salt", to: "Amine", reagents: ["H‚ÇÇO"], conditions: ["basic"], type: ["Acid-Base"], fact: "Base liberates free amine." },
      { from: "Carboxylic Acid", to: "Carboxylate", reagents: ["H‚ÇÇO"], conditions: ["basic"], type: ["Acid-Base"], fact: "Base forms carboxylate ion." },
      { from: "Carboxylate", to: "Carboxylic Acid", reagents: ["H‚ÇÇO"], conditions: ["acidic"], type: ["Acid-Base"], fact: "Acid reprotonates carboxylate." }
    ];

    const validStarters = [...new Set(reactions.map(r => r.from))];
    const validTargets = [...new Set(reactions.map(r => r.to))];

    const difficultySteps = {
      baby: { min: 2, max: 2 },
      easy: { min: 2, max: 3 },
      med: { min: 3, max: 4 },
      hard: { min: 4, max: 5 },
      evil: { min: 8, max: 10 }
    };

    // === Theme Toggle ===
    $("theme-toggle").addEventListener("click", () => {
      isDark = !isDark;
      document.body.setAttribute("data-theme", isDark ? "dark" : "light");
      $("theme-toggle").textContent = isDark ? "‚òÄÔ∏è Light" : "üåô Dark";
    });

    // === Sticky Toggle ===
    $("sticky-toggle").addEventListener("click", () => {
      isSticky = !isSticky;
      const container = document.querySelector('.container');
      if (isSticky) {
        container.classList.add('sticky-pools');
      } else {
        container.classList.remove('sticky-pools');
      }
      $("sticky-toggle").textContent = isSticky ? "üìç Unpin" : "üìå Sticky Pools";
    });

    // === Difficulty Buttons ===
    document.querySelectorAll(".diff-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".diff-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const newDifficulty = btn.id.replace("diff-", "");
        if (newDifficulty !== difficulty) {
          difficulty = newDifficulty;
          reset();
        }
      });
    });

    // === Reset Game ===
    function reset() {
      correctPath = [];
      userSteps = [];
      feedbackEl.style.display = "none";
      factEl.style.display = "none";
      $("steps-container").innerHTML = "";
      $("conditions-pool").innerHTML = "";
      $("reagents-pool").innerHTML = "";
      $("products-pool").innerHTML = "";
      initGame();
    }

    // === Init Game ===
    function initGame() {
      start = validStarters[Math.floor(Math.random() * validStarters.length)];
      target = validTargets[Math.floor(Math.random() * validTargets.length)];

      $("start").textContent = start;
      $("target").textContent = target;

      let path = null;

      if (difficulty === "evil") {
        // Evil: force long path with constraints
        path = findLongPathWithConstraints(start, target, difficultySteps.evil);
      } else {
        // All others: shortest path
        path = findShortestPath(start, target);
      }

      if (!path || path.length === 0) return setTimeout(initGame, 100);

      correctPath = path;
      userSteps = path.map(() => ({
        condition: [],
        reagent: [],
        product: null
      }));

      // Pre-fill some steps on Evil mode
      if (difficulty === "evil") {
        applyEvilConstraints();
      }

      renderSteps();
      generatePools();
    }

    // === SHORTEST PATH (BFS, no repeats) ===
    function findShortestPath(from, to) {
      const queue = [[from]];
      const visited = new Set();

      while (queue.length) {
        const path = queue.shift();
        const last = path[path.length - 1];

        if (last === to) {
          return buildReactionPath(path);
        }

        // Avoid cycles
        if (path.length > 10) continue;
        const visitKey = `${last}|${path.length}`;
        if (visited.has(visitKey)) continue;
        visited.add(visitKey);

        reactions.forEach(r => {
          if (r.from === last && !path.includes(r.to)) {  // No cycles
            queue.push([...path, r.to]);
          }
        });
      }
      return null;
    }

    // === EVIL: Long path with forced steps ===
    function findLongPathWithConstraints(from, to, range) {
      // First, try to find a path longer than shortest
      const shortest = findShortestPath(from, to);
      const shortestLength = shortest ? shortest.length : 1;

      const maxAttempts = 500;
      for (let i = 0; i < maxAttempts; i++) {
        const path = randomLongPath(from, to, range.min, range.max);
        if (path && path.length >= range.min && path.length !== shortestLength) {
          return path;
        }
      }
      // Fallback: return shortest if no long path found
      return shortest;
    }

    function randomLongPath(from, to, min, max) {
      const path = [from];
      const maxSteps = Math.min(max, 10);

      while (path.length < maxSteps) {
        const last = path[path.length - 1];
        if (last === to && path.length >= min) break;

        const candidates = reactions
          .filter(r => r.from === last && !path.includes(r.to)) // Avoid immediate loops
          .map(r => r.to);

        if (candidates.length === 0) break;

        const next = candidates[Math.floor(Math.random() * candidates.length)];
        path.push(next);
      }

      if (path[path.length - 1] === to && path.length >= min) {
        return buildReactionPath(path);
      }
      return null;
    }

    function buildReactionPath(nodes) {
      return nodes.slice(0, -1).map((from, i) => {
        const to = nodes[i + 1];
        return reactions.find(r => r.from === from && r.to === to) || null;
      }).filter(Boolean);
    }

    // === EVIL: Force some reagents ===
    function applyEvilConstraints() {
      const forceReagents = ["conc. NH‚ÇÉ", "Cr‚ÇÇO‚Çá¬≤‚Åª / H‚Å∫", "H‚ÇÇO", "NaBH‚ÇÑ"];
      const forceStep = Math.floor(Math.random() * correctPath.length);
      const forcedReagent = forceReagents[Math.floor(Math.random() * forceReagents.length)];

      // Modify reaction to use forced reagent if possible
      const step = correctPath[forceStep];
      if (step && step.reagents.includes(forcedReagent)) {
        // Already uses it? Cool.
      } else {
        // Replace reagent with forced one if possible
        const alt = reactions.find(r => r.from === step.from && r.to === step.to && r.reagents.includes(forcedReagent));
        if (alt) {
          correctPath[forceStep] = alt;
        }
      }

      // Pre-fill user step
      userSteps[forceStep].reagent = [forcedReagent];
      userSteps[forceStep].condition = [...(correctPath[forceStep].conditions || [])];
    }

    // === Render Steps ===
    function renderSteps() {
      const container = $("steps-container");
      container.innerHTML = "";

      correctPath.forEach((step, i) => {
        const stepDiv = document.createElement("div");
        stepDiv.className = "step";

        const condDrop = createDropZone("condition", i, userSteps[i].condition);
        const condCol = document.createElement("div");
        condCol.className = "condition-drop";
        condCol.appendChild(condDrop);

        const arrowCol = document.createElement("div");
        arrowCol.className = "arrow-container";
        const arrow = document.createElement("div");
        arrow.className = "arrow";
        arrow.textContent = "‚Üì";
        arrowCol.appendChild(arrow);

        const reagDrop = createDropZone("reagent", i, userSteps[i].reagent);
        const reagCol = document.createElement("div");
        reagCol.className = "reagent-drop";
        reagCol.appendChild(reagDrop);

        stepDiv.appendChild(condCol);
        stepDiv.appendChild(arrowCol);
        stepDiv.appendChild(reagCol);
        container.appendChild(stepDiv);

        if (i < correctPath.length - 1) {
          const prodDrop = createDropZone("product", i, userSteps[i].product ? [userSteps[i].product] : []);
          prodDrop.dataset.single = "true";
          const prodRow = document.createElement("div");
          prodRow.className = "product-drop";
          prodRow.appendChild(prodDrop);
          container.appendChild(prodRow);
        } else {
          userSteps[i].product = step.to;
        }
      });
    }

    // === Create Drop Zone ===
    function createDropZone(type, stepIndex, values) {
      const dropZone = document.createElement("div");
      dropZone.className = "drop-zone";
      dropZone.dataset.step = stepIndex;
      dropZone.dataset.type = type;
      dropZone.textContent = values.length === 0 ? (type === "product" ? "Intermediate" : type.charAt(0).toUpperCase() + type.slice(1)) : "";

      if (values.length > 0) {
        dropZone.innerHTML = "";
        values.forEach(val => {
          const tag = document.createElement("span");
          tag.className = "tag";
          tag.textContent = val;
          tag.addEventListener("click", (e) => {
            e.stopPropagation();
            if (dropZone.dataset.single === "true") {
              userSteps[stepIndex][type] = null;
              dropZone.innerHTML = "";
              dropZone.textContent = type === "product" ? "Intermediate" : type.charAt(0).toUpperCase() + type.slice(1);
            } else {
              const arr = userSteps[stepIndex][type];
              const i = arr.indexOf(val);
              if (i > -1) arr.splice(i, 1);
              tag.remove();
              if (arr.length === 0) {
                dropZone.textContent = type === "product" ? "Intermediate" : type.charAt(0).toUpperCase() + type.slice(1);
              }
            }
          });
          dropZone.appendChild(tag);
        });
        dropZone.classList.add("filled");
      }

      dropZone.addEventListener("dragover", e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
      dropZone.addEventListener("drop", handleDrop);

      return dropZone;
    }

    // === Generate Pools ===
    function generatePools() {
      const allReagents = new Set();
      const allConditions = new Set(["None"]);
      const allProducts = new Set();

      reactions.forEach(r => {
        r.reagents.forEach(rg => allReagents.add(rg));
        if (r.conditions.length === 0) {
          allConditions.add("None");
        } else {
          r.conditions.forEach(c => allConditions.add(c));
        }
        allProducts.add(r.to);
      });

      Array.from(allConditions).sort().forEach(c => {
        const el = createDraggable(c, "condition");
        $("conditions-pool").appendChild(el);
      });

      Array.from(allReagents).sort().forEach(r => {
        const el = createDraggable(r, "reagent");
        $("reagents-pool").appendChild(el);
      });

      Array.from(allProducts).sort().forEach(p => {
        const el = createDraggable(p, "product");
        $("products-pool").appendChild(el);
      });

      if (!allProducts.has(start)) {
        const startEl = createDraggable(start, "product");
        $("products-pool").appendChild(startEl);
      }
    }

    function createDraggable(text, kind) {
      const el = document.createElement("div");
      el.className = `draggable ${kind}`;
      el.textContent = text;
      el.draggable = true;
      el.dataset.kind = kind;
      el.addEventListener("dragstart", e => {
        e.dataTransfer.setData("text/plain", e.target.textContent);
        e.dataTransfer.effectAllowed = "copyMove";
      });
      return el;
    }

    // === Handle Drop ===
    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const data = e.dataTransfer.getData("text/plain");
      let dropZone = e.target;
      while (dropZone && !dropZone.classList.contains("drop-zone")) {
        dropZone = dropZone.parentElement;
      }
      if (!dropZone || !dropZone.dataset.step || !dropZone.dataset.type) return;

      const stepIndex = parseInt(dropZone.dataset.step);
      const type = dropZone.dataset.type;
      const isSingle = dropZone.dataset.single === "true";

      if (dropZone.textContent.includes("Intermediate") || dropZone.textContent.includes("Condition") || dropZone.textContent.includes("Reagent")) {
        dropZone.innerHTML = "";
      }

      if (isSingle) {
        dropZone.innerHTML = "";
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = data;
        dropZone.appendChild(tag);
        userSteps[stepIndex].product = data;
        dropZone.classList.add("filled");
        return;
      }

      const arr = userSteps[stepIndex][type];
      if (!arr.includes(data)) {
        arr.push(data);
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = data;
        tag.addEventListener("click", (e) => {
          e.stopPropagation();
          const i = arr.indexOf(data);
          if (i > -1) arr.splice(i, 1);
          tag.remove();
          if (arr.length === 0) {
            dropZone.textContent = type === "product" ? "Intermediate" : type.charAt(0).toUpperCase() + type.slice(1);
            dropZone.classList.remove("filled");
          }
        });
        dropZone.appendChild(tag);
        dropZone.classList.add("filled");
      }
    }

    // === Helpful Hint ===
    $("helpful-hint").addEventListener("click", () => {
      const emptyZones = [];
      userSteps.forEach((step, i) => {
        if (step.condition.length === 0) emptyZones.push({stepIndex: i, type: 'condition'});
        if (step.reagent.length === 0) emptyZones.push({stepIndex: i, type: 'reagent'});
        if (step.product === null && i < correctPath.length - 1) emptyZones.push({stepIndex: i, type: 'product'});
      });

      if (emptyZones.length === 0) {
        feedbackEl.style.display = "block";
        feedbackEl.className = "feedback ok";
        feedbackEl.textContent = "üí° All boxes are filled! Try submitting.";
        return;
      }

      const randomZone = emptyZones[Math.floor(Math.random() * emptyZones.length)];
      const stepIndex = randomZone.stepIndex;
      const type = randomZone.type;
      const step = correctPath[stepIndex];

      let value = "";
      if (type === "condition") {
        value = step.conditions.length === 0 ? "None" : step.conditions[0];
      } else if (type === "reagent") {
        value = step.reagents[0];
      } else if (type === "product") {
        value = step.to;
      }

      const dropZones = document.querySelectorAll(`[data-step="${stepIndex}"][data-type="${type}"]`);
      if (dropZones.length > 0) {
        const dropZone = dropZones[0];
        if (type === "product") {
          dropZone.innerHTML = `<span class="tag">${value}</span>`;
          userSteps[stepIndex].product = value;
        } else {
          const arr = userSteps[stepIndex][type];
          if (!arr.includes(value)) {
            arr.push(value);
            const tag = document.createElement("span");
            tag.className = "tag";
            tag.textContent = value;
            dropZone.appendChild(tag);
            if (arr.length === 1) dropZone.textContent = "";
          }
        }
        dropZone.classList.add("filled");

        feedbackEl.style.display = "block";
        feedbackEl.className = "feedback ok";
        feedbackEl.textContent = `üí° Hint: Added ${value} to step ${stepIndex + 1}.`;
      }
    });

    // === Submit ===
    $("submit").addEventListener("click", () => {
      const allFilled = userSteps.every((s, i) => {
        const hasCond = s.condition.length > 0 || (correctPath[i].conditions.length === 0);
        const hasReag = s.reagent.length > 0;
        const hasProd = i === correctPath.length - 1 || s.product !== null;
        return hasCond && hasReag && hasProd;
      });

      const allCorrect = userSteps.every((s, i) => {
        const r = correctPath[i];
        const condMatch = r.conditions.every(c => s.condition.includes(c));
        const reagMatch = r.reagents.every(rg => s.reagent.includes(rg));
        const prodMatch = i === correctPath.length - 1 || s.product === r.to;
        return condMatch && reagMatch && prodMatch;
      });

      feedbackEl.style.display = "block";
      factEl.style.display = "none";

      if (allFilled && allCorrect) {
        feedbackEl.className = "feedback ok";
        feedbackEl.textContent = `‚úÖ Success! You reached ${target} in ${correctPath.length} steps.`;
      } else if (!allFilled) {
        feedbackEl.className = "feedback bad";
        feedbackEl.textContent = "‚ùå Please complete all fields in each step.";
      } else {
        feedbackEl.className = "feedback bad";
        feedbackEl.textContent = "‚ùå Some entries are incorrect. Check reagents, conditions, and products.";
      }
    });

    // === Show Answer ===
    $("show-answer").addEventListener("click", () => {
      let ans = `Target: ${target}\nStart: ${start}\n\n`;
      correctPath.forEach(s => {
        ans += `${s.from} ‚Üí ${s.to}\n`;
        ans += `Reagent: ${s.reagents.join(" and ")}\n`;
        ans += `Condition: ${s.conditions.length ? s.conditions.join(" and ") : "None"}\n`;
        ans += `${s.fact}\n\n`;
      });
      factEl.textContent = ans;
      factEl.style.display = "block";
    });

    $("reset").addEventListener("click", reset);

    // Start the game
    reset();
  });
</script>
</body>
</html>
